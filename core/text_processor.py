import re
from typing import List, Set


class TextProcessor:
    """Класс для обработки текста и пользовательских запросов"""
    
    def __init__(self):
        self.stop_words = self._load_russian_stop_words()
        self.word_endings = self._load_word_endings()
    
    def _load_russian_stop_words(self) -> Set[str]:
        """Загрузка русских стоп-слов"""
        return {
            'и', 'в', 'во', 'не', 'что', 'он', 'на', 'я', 'с', 'со', 'как', 'а', 'то', 'все', 'она', 'так', 'его', 'но', 'да', 'ты', 'к', 'у', 'же', 'вы', 'за', 'бы', 'по', 'только', 'ее', 'мне', 'было', 'вот', 'от', 'меня', 'еще', 'нет', 'о', 'из', 'ему', 'теперь', 'когда', 'даже', 'ну', 'вдруг', 'ли', 'если', 'уже', 'или', 'ни', 'быть', 'был', 'него', 'до', 'вас', 'нибудь', 'опять', 'уж', 'вам', 'ведь', 'там', 'потом', 'себя', 'ничего', 'ей', 'может', 'они', 'тут', 'где', 'есть', 'надо', 'ней', 'для', 'мы', 'тебя', 'их', 'чем', 'была', 'сам', 'чтоб', 'без', 'будто', 'чего', 'раз', 'тоже', 'себе', 'под', 'будет', 'ж', 'тогда', 'кто', 'этот', 'того', 'потому', 'этого', 'какой', 'совсем', 'ним', 'здесь', 'этом', 'один', 'почти', 'мой', 'тем', 'чтобы', 'нее', 'сейчас', 'были', 'куда', 'зачем', 'всех', 'никогда', 'можно', 'при', 'наконец', 'два', 'об', 'другой', 'хоть', 'после', 'над', 'больше', 'тот', 'через', 'эти', 'нас', 'про', 'всего', 'них', 'какая', 'много', 'разве', 'три', 'эту', 'моя', 'впрочем', 'хорошо', 'свою', 'этой', 'перед', 'иногда', 'лучше', 'чуть', 'том', 'нельзя', 'такой', 'им', 'более', 'всегда', 'конечно', 'всю', 'между'
        }
    
    def _load_word_endings(self) -> List[str]:
        """Загрузка русских окончаний для базового стемминга"""
        return [
            # Множественное число, творительный падеж
            'ами', 'ями', 'ьми',
            # Предложный падеж
            'ах', 'ях', 'ьях',
            # Дательный падеж
            'ам', 'ям', 'ьям',
            # Родительный падеж множественного числа
            'ов', 'ев', 'ей', 'ий', 'ьев', 'ьей',
            # Винительный падеж
            'ую', 'юю', 'ую', 'юю',
            # Творительный падеж
            'ой', 'ей', 'ою', 'ею', 'ым', 'им',
            # Родительный падеж
            'ого', 'его', 'ой', 'ей', 'ых', 'их',
            # Именительный падеж множественного числа
            'ые', 'ие', 'ые', 'ие',
            # Именительный падеж единственного числа (прилагательные)
            'ый', 'ий', 'ая', 'яя', 'ое', 'ее',
            # Окончания глаголов
            'ется', 'ются', 'ешь', 'ете', 'ет', 'ут', 'ют', 'ишь', 'ите', 'ит', 'ат', 'ят',
            'уть', 'ить', 'еть', 'ать', 'оть', 'ыть',
            'ал', 'ала', 'али', 'ало', 'ела', 'ели', 'ело', 'ил', 'ила', 'или', 'ило',
            'ул', 'ула', 'ули', 'уло',
            # Причастия и деепричастия
            'щий', 'щая', 'щее', 'щие', 'вший', 'вшая', 'вшее', 'вшие',
            'я', 'а', 'о', 'е', 'и', 'ы', 'у', 'ю'
        ]
    
    def _simple_stem(self, word: str) -> str:
        """
        Простой стемминг без использования сторонних библиотек
        Удаляет наиболее частые окончания русского языка
        """
        if len(word) < 4:
            return word
        
        # Сортируем окончания по длине (от длинных к коротким)
        sorted_endings = sorted(self.word_endings, key=len, reverse=True)
        
        for ending in sorted_endings:
            if word.endswith(ending) and len(word) - len(ending) >= 2:
                return word[:-len(ending)]
        
        return word
    
    def preprocess_text(self, text: str) -> str:
        """
        Обрабатывает пользовательский запрос на русском языке и приводит его к единому формату
        
        Args:
            text (str): Исходный текст запроса
            
        Returns:
            str: Обработанный и нормализованный текст
        """
        if not text or not isinstance(text, str):
            return ""
        
        # 1. Приведение к нижнему регистру
        text = text.lower()
        
        # 2. Удаление лишних символов и цифр, оставляем только буквы и пробелы
        text = re.sub(r'[^а-яё\s]', ' ', text)
        
        # 3. Удаление множественных пробелов
        text = re.sub(r'\s+', ' ', text)
        
        # 4. Разбивка на слова
        words = text.split()
        
        # 5. Удаление стоп-слов
        words = [word for word in words if word not in self.stop_words and len(word) > 2]
        
        # 6. Простой стемминг (удаление окончаний)
        stemmed_words = []
        for word in words:
            stemmed_word = self._simple_stem(word)
            stemmed_words.append(stemmed_word)
        
        # 7. Фильтрация коротких слов после стемминга
        stemmed_words = [word for word in stemmed_words if len(word) > 1]
        
        # 8. Объединение в строку
        result = ' '.join(stemmed_words)
        
        return result.strip()
    
    def extract_keywords(self, text: str) -> List[str]:
        """
        Извлекает ключевые слова из текста
        
        Args:
            text (str): Исходный текст
            
        Returns:
            List[str]: Список ключевых слов
        """
        processed_text = self.preprocess_text(text)
        return processed_text.split() if processed_text else []
    
    def normalize_query(self, query: str) -> str:
        """
        Дополнительная нормализация запроса для поиска
        
        Args:
            query (str): Пользовательский запрос
            
        Returns:
            str: Нормализованный запрос
        """
        # Основная обработка
        normalized = self.preprocess_text(query)
        
        # Дополнительная обработка для улучшения поиска
        if normalized:
            # Удаляем дублирующиеся слова
            words = normalized.split()
            unique_words = []
            seen = set()
            for word in words:
                if word not in seen:
                    unique_words.append(word)
                    seen.add(word)
            normalized = ' '.join(unique_words)
        
        return normalized


def preprocess_request(request: str) -> str:
    """
    Функция для предобработки пользовательского запроса
    
    Args:
        request (str): Пользовательский запрос
        
    Returns:
        str: Обработанный запрос
    """
    processor = TextProcessor()
    return processor.preprocess_text(request)